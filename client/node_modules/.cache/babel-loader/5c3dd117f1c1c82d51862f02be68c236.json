{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\n\n\nexport function boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n\n  if (typeof fn !== 'function') {\n    throw new TypeError(\"@boundMethod decorator can only be applied to methods not: \".concat(_typeof(fn)));\n  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n\n\n  var definingProperty = false;\n  return {\n    configurable: true,\n    get: function get() {\n      // eslint-disable-next-line no-prototype-builtins\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key) || typeof fn !== 'function') {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        configurable: true,\n        get: function get() {\n          return boundFn;\n        },\n        set: function set(value) {\n          fn = value;\n          delete this[key];\n        }\n      });\n      definingProperty = false;\n      return boundFn;\n    },\n    set: function set(value) {\n      fn = value;\n    }\n  };\n}\n/**\n * Use boundMethod to bind all methods on the target.prototype\n */\n\nexport function boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys; // Use Reflect if exists\n\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype); // Use symbols if support is provided\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === 'constructor') {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding\n\n    if (typeof descriptor.value === 'function') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\nexport default function autobind() {\n  if (arguments.length === 1) {\n    return boundClass.apply(void 0, arguments);\n  }\n\n  return boundMethod.apply(void 0, arguments);\n}","map":{"version":3,"sources":["/Users/johnlinnane/DEV/tc-book/node_modules/autobind-decorator/lib/esm/index.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","boundMethod","target","key","descriptor","fn","value","TypeError","concat","definingProperty","configurable","get","hasOwnProperty","boundFn","bind","Object","defineProperty","set","boundClass","keys","Reflect","ownKeys","getOwnPropertyNames","getOwnPropertySymbols","forEach","getOwnPropertyDescriptor","autobind","arguments","length","apply"],"mappings":"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","sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\nexport function boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n\n  if (typeof fn !== 'function') {\n    throw new TypeError(\"@boundMethod decorator can only be applied to methods not: \".concat(_typeof(fn)));\n  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n\n\n  var definingProperty = false;\n  return {\n    configurable: true,\n    get: function get() {\n      // eslint-disable-next-line no-prototype-builtins\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key) || typeof fn !== 'function') {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        configurable: true,\n        get: function get() {\n          return boundFn;\n        },\n        set: function set(value) {\n          fn = value;\n          delete this[key];\n        }\n      });\n      definingProperty = false;\n      return boundFn;\n    },\n    set: function set(value) {\n      fn = value;\n    }\n  };\n}\n/**\n * Use boundMethod to bind all methods on the target.prototype\n */\n\nexport function boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys; // Use Reflect if exists\n\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype); // Use symbols if support is provided\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === 'constructor') {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding\n\n    if (typeof descriptor.value === 'function') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\nexport default function autobind() {\n  if (arguments.length === 1) {\n    return boundClass.apply(void 0, arguments);\n  }\n\n  return boundMethod.apply(void 0, arguments);\n}"]},"metadata":{},"sourceType":"module"}
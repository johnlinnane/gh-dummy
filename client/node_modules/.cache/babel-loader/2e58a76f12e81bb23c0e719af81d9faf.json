{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar matchesType_1 = require(\"../utils/matchesType\");\n\nvar invariant = require('invariant');\n\nvar isObject = require('lodash/isObject');\n\nexports.BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';\nexports.PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';\nexports.HOVER = 'dnd-core/HOVER';\nexports.DROP = 'dnd-core/DROP';\nexports.END_DRAG = 'dnd-core/END_DRAG';\n\nfunction createDragDropActions(manager) {\n  return {\n    beginDrag: function (sourceIds, _a) {\n      if (sourceIds === void 0) {\n        sourceIds = [];\n      }\n\n      var _b = _a === void 0 ? {\n        publishSource: true\n      } : _a,\n          publishSource = _b.publishSource,\n          clientOffset = _b.clientOffset,\n          getSourceClientOffset = _b.getSourceClientOffset;\n\n      var monitor = manager.getMonitor();\n      var registry = manager.getRegistry();\n      invariant(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');\n\n      for (var _i = 0, sourceIds_1 = sourceIds; _i < sourceIds_1.length; _i++) {\n        var s = sourceIds_1[_i];\n        invariant(registry.getSource(s), 'Expected sourceIds to be registered.');\n      }\n\n      var sourceId = null;\n\n      for (var i = sourceIds.length - 1; i >= 0; i--) {\n        if (monitor.canDragSource(sourceIds[i])) {\n          sourceId = sourceIds[i];\n          break;\n        }\n      }\n\n      if (sourceId === null) {\n        return;\n      }\n\n      var sourceClientOffset = null;\n\n      if (clientOffset) {\n        invariant(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');\n        sourceClientOffset = getSourceClientOffset(sourceId);\n      }\n\n      var source = registry.getSource(sourceId);\n      var item = source.beginDrag(monitor, sourceId);\n      invariant(isObject(item), 'Item must be an object.');\n      registry.pinSource(sourceId);\n      var itemType = registry.getSourceType(sourceId);\n      return {\n        type: exports.BEGIN_DRAG,\n        payload: {\n          itemType: itemType,\n          item: item,\n          sourceId: sourceId,\n          clientOffset: clientOffset || null,\n          sourceClientOffset: sourceClientOffset || null,\n          isSourcePublic: !!publishSource\n        }\n      };\n    },\n    publishDragSource: function () {\n      var monitor = manager.getMonitor();\n\n      if (!monitor.isDragging()) {\n        return;\n      }\n\n      return {\n        type: exports.PUBLISH_DRAG_SOURCE\n      };\n    },\n    hover: function (targetIdsArg, _a) {\n      var clientOffset = (_a === void 0 ? {} : _a).clientOffset;\n      invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n      var targetIds = targetIdsArg.slice(0);\n      var monitor = manager.getMonitor();\n      var registry = manager.getRegistry();\n      invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n      invariant(!monitor.didDrop(), 'Cannot call hover after drop.'); // First check invariants.\n\n      for (var i = 0; i < targetIds.length; i++) {\n        var targetId = targetIds[i];\n        invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n        var target = registry.getTarget(targetId);\n        invariant(target, 'Expected targetIds to be registered.');\n      }\n\n      var draggedItemType = monitor.getItemType(); // Remove those targetIds that don't match the targetType.  This\n      // fixes shallow isOver which would only be non-shallow because of\n      // non-matching targets.\n\n      for (var i = targetIds.length - 1; i >= 0; i--) {\n        var targetId = targetIds[i];\n        var targetType = registry.getTargetType(targetId);\n\n        if (!matchesType_1.default(targetType, draggedItemType)) {\n          targetIds.splice(i, 1);\n        }\n      } // Finally call hover on all matching targets.\n\n\n      for (var _i = 0, targetIds_1 = targetIds; _i < targetIds_1.length; _i++) {\n        var targetId = targetIds_1[_i];\n        var target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n      }\n\n      return {\n        type: exports.HOVER,\n        payload: {\n          targetIds: targetIds,\n          clientOffset: clientOffset || null\n        }\n      };\n    },\n    drop: function (options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var monitor = manager.getMonitor();\n      var registry = manager.getRegistry();\n      invariant(monitor.isDragging(), 'Cannot call drop while not dragging.');\n      invariant(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n      var targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n      targetIds.reverse(); // Multiple actions are dispatched here, which is why this doesn't return an action\n\n      targetIds.forEach(function (targetId, index) {\n        var target = registry.getTarget(targetId);\n        var dropResult = target.drop(monitor, targetId);\n        invariant(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');\n\n        if (typeof dropResult === 'undefined') {\n          dropResult = index === 0 ? {} : monitor.getDropResult();\n        }\n\n        var action = {\n          type: exports.DROP,\n          payload: {\n            dropResult: __assign({}, options, dropResult)\n          }\n        };\n        manager.dispatch(action);\n      });\n    },\n    endDrag: function () {\n      var monitor = manager.getMonitor();\n      var registry = manager.getRegistry();\n      invariant(monitor.isDragging(), 'Cannot call endDrag while not dragging.');\n      var sourceId = monitor.getSourceId();\n      var source = registry.getSource(sourceId, true);\n      source.endDrag(monitor, sourceId);\n      registry.unpinSource();\n      return {\n        type: exports.END_DRAG\n      };\n    }\n  };\n}\n\nexports.default = createDragDropActions;","map":{"version":3,"sources":["/Users/johnlinnane/DEV/tc-book/node_modules/react-dnd/node_modules/dnd-core/lib/actions/dragDrop.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","defineProperty","exports","value","matchesType_1","require","invariant","isObject","BEGIN_DRAG","PUBLISH_DRAG_SOURCE","HOVER","DROP","END_DRAG","createDragDropActions","manager","beginDrag","sourceIds","_a","_b","publishSource","clientOffset","getSourceClientOffset","monitor","getMonitor","registry","getRegistry","isDragging","_i","sourceIds_1","getSource","sourceId","canDragSource","sourceClientOffset","source","item","pinSource","itemType","getSourceType","type","payload","isSourcePublic","publishDragSource","hover","targetIdsArg","Array","isArray","targetIds","slice","didDrop","targetId","lastIndexOf","target","getTarget","draggedItemType","getItemType","targetType","getTargetType","default","splice","targetIds_1","drop","options","getTargetIds","filter","canDropOnTarget","reverse","forEach","index","dropResult","getDropResult","action","dispatch","endDrag","getSourceId","unpinSource"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar matchesType_1 = require(\"../utils/matchesType\");\nvar invariant = require('invariant');\nvar isObject = require('lodash/isObject');\nexports.BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';\nexports.PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';\nexports.HOVER = 'dnd-core/HOVER';\nexports.DROP = 'dnd-core/DROP';\nexports.END_DRAG = 'dnd-core/END_DRAG';\nfunction createDragDropActions(manager) {\n    return {\n        beginDrag: function (sourceIds, _a) {\n            if (sourceIds === void 0) { sourceIds = []; }\n            var _b = _a === void 0 ? {\n                publishSource: true,\n            } : _a, publishSource = _b.publishSource, clientOffset = _b.clientOffset, getSourceClientOffset = _b.getSourceClientOffset;\n            var monitor = manager.getMonitor();\n            var registry = manager.getRegistry();\n            invariant(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');\n            for (var _i = 0, sourceIds_1 = sourceIds; _i < sourceIds_1.length; _i++) {\n                var s = sourceIds_1[_i];\n                invariant(registry.getSource(s), 'Expected sourceIds to be registered.');\n            }\n            var sourceId = null;\n            for (var i = sourceIds.length - 1; i >= 0; i--) {\n                if (monitor.canDragSource(sourceIds[i])) {\n                    sourceId = sourceIds[i];\n                    break;\n                }\n            }\n            if (sourceId === null) {\n                return;\n            }\n            var sourceClientOffset = null;\n            if (clientOffset) {\n                invariant(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');\n                sourceClientOffset = getSourceClientOffset(sourceId);\n            }\n            var source = registry.getSource(sourceId);\n            var item = source.beginDrag(monitor, sourceId);\n            invariant(isObject(item), 'Item must be an object.');\n            registry.pinSource(sourceId);\n            var itemType = registry.getSourceType(sourceId);\n            return {\n                type: exports.BEGIN_DRAG,\n                payload: {\n                    itemType: itemType,\n                    item: item,\n                    sourceId: sourceId,\n                    clientOffset: clientOffset || null,\n                    sourceClientOffset: sourceClientOffset || null,\n                    isSourcePublic: !!publishSource,\n                },\n            };\n        },\n        publishDragSource: function () {\n            var monitor = manager.getMonitor();\n            if (!monitor.isDragging()) {\n                return;\n            }\n            return { type: exports.PUBLISH_DRAG_SOURCE };\n        },\n        hover: function (targetIdsArg, _a) {\n            var clientOffset = (_a === void 0 ? {} : _a).clientOffset;\n            invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n            var targetIds = targetIdsArg.slice(0);\n            var monitor = manager.getMonitor();\n            var registry = manager.getRegistry();\n            invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n            invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n            // First check invariants.\n            for (var i = 0; i < targetIds.length; i++) {\n                var targetId = targetIds[i];\n                invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n                var target = registry.getTarget(targetId);\n                invariant(target, 'Expected targetIds to be registered.');\n            }\n            var draggedItemType = monitor.getItemType();\n            // Remove those targetIds that don't match the targetType.  This\n            // fixes shallow isOver which would only be non-shallow because of\n            // non-matching targets.\n            for (var i = targetIds.length - 1; i >= 0; i--) {\n                var targetId = targetIds[i];\n                var targetType = registry.getTargetType(targetId);\n                if (!matchesType_1.default(targetType, draggedItemType)) {\n                    targetIds.splice(i, 1);\n                }\n            }\n            // Finally call hover on all matching targets.\n            for (var _i = 0, targetIds_1 = targetIds; _i < targetIds_1.length; _i++) {\n                var targetId = targetIds_1[_i];\n                var target = registry.getTarget(targetId);\n                target.hover(monitor, targetId);\n            }\n            return {\n                type: exports.HOVER,\n                payload: {\n                    targetIds: targetIds,\n                    clientOffset: clientOffset || null,\n                },\n            };\n        },\n        drop: function (options) {\n            if (options === void 0) { options = {}; }\n            var monitor = manager.getMonitor();\n            var registry = manager.getRegistry();\n            invariant(monitor.isDragging(), 'Cannot call drop while not dragging.');\n            invariant(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n            var targetIds = monitor\n                .getTargetIds()\n                .filter(monitor.canDropOnTarget, monitor);\n            targetIds.reverse();\n            // Multiple actions are dispatched here, which is why this doesn't return an action\n            targetIds.forEach(function (targetId, index) {\n                var target = registry.getTarget(targetId);\n                var dropResult = target.drop(monitor, targetId);\n                invariant(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');\n                if (typeof dropResult === 'undefined') {\n                    dropResult = index === 0 ? {} : monitor.getDropResult();\n                }\n                var action = {\n                    type: exports.DROP,\n                    payload: {\n                        dropResult: __assign({}, options, dropResult),\n                    },\n                };\n                manager.dispatch(action);\n            });\n        },\n        endDrag: function () {\n            var monitor = manager.getMonitor();\n            var registry = manager.getRegistry();\n            invariant(monitor.isDragging(), 'Cannot call endDrag while not dragging.');\n            var sourceId = monitor.getSourceId();\n            var source = registry.getSource(sourceId, true);\n            source.endDrag(monitor, sourceId);\n            registry.unpinSource();\n            return { type: exports.END_DRAG };\n        },\n    };\n}\nexports.default = createDragDropActions;\n"]},"metadata":{},"sourceType":"script"}
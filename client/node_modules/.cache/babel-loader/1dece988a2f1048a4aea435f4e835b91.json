{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BrowserDetector_1 = require(\"./BrowserDetector\");\n\nvar MonotonicInterpolant_1 = __importDefault(require(\"./MonotonicInterpolant\"));\n\nvar ELEMENT_NODE = 1;\n\nfunction getNodeClientOffset(node) {\n  var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n\n  if (!el) {\n    return null;\n  }\n\n  var _a = el.getBoundingClientRect(),\n      top = _a.top,\n      left = _a.left;\n\n  return {\n    x: left,\n    y: top\n  };\n}\n\nexports.getNodeClientOffset = getNodeClientOffset;\n\nfunction getEventClientOffset(e) {\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n}\n\nexports.getEventClientOffset = getEventClientOffset;\n\nfunction isImageNode(node) {\n  return node.nodeName === 'IMG' && (BrowserDetector_1.isFirefox() || !document.documentElement.contains(node));\n}\n\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n  var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n  var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight; // Work around @2x coordinate discrepancies in browsers\n\n  if (BrowserDetector_1.isSafari() && isImage) {\n    dragPreviewHeight /= window.devicePixelRatio;\n    dragPreviewWidth /= window.devicePixelRatio;\n  }\n\n  return {\n    dragPreviewWidth: dragPreviewWidth,\n    dragPreviewHeight: dragPreviewHeight\n  };\n}\n\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n  // The browsers will use the image intrinsic size under different conditions.\n  // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n  var isImage = isImageNode(dragPreview);\n  var dragPreviewNode = isImage ? sourceNode : dragPreview;\n  var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n  var offsetFromDragPreview = {\n    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n  };\n  var sourceWidth = sourceNode.offsetWidth,\n      sourceHeight = sourceNode.offsetHeight;\n  var anchorX = anchorPoint.anchorX,\n      anchorY = anchorPoint.anchorY;\n\n  var _a = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight),\n      dragPreviewWidth = _a.dragPreviewWidth,\n      dragPreviewHeight = _a.dragPreviewHeight;\n\n  var calculateYOffset = function () {\n    var interpolantY = new MonotonicInterpolant_1.default([0, 0.5, 1], [// Dock to the top\n    offsetFromDragPreview.y, // Align at the center\n    offsetFromDragPreview.y / sourceHeight * dragPreviewHeight, // Dock to the bottom\n    offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);\n    var y = interpolantY.interpolate(anchorY); // Work around Safari 8 positioning bug\n\n    if (BrowserDetector_1.isSafari() && isImage) {\n      // We'll have to wait for @3x to see if this is entirely correct\n      y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n    }\n\n    return y;\n  };\n\n  var calculateXOffset = function () {\n    // Interpolate coordinates depending on anchor point\n    // If you know a simpler way to do this, let me know\n    var interpolantX = new MonotonicInterpolant_1.default([0, 0.5, 1], [// Dock to the left\n    offsetFromDragPreview.x, // Align at the center\n    offsetFromDragPreview.x / sourceWidth * dragPreviewWidth, // Dock to the right\n    offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);\n    return interpolantX.interpolate(anchorX);\n  }; // Force offsets if specified in the options.\n\n\n  var offsetX = offsetPoint.offsetX,\n      offsetY = offsetPoint.offsetY;\n  var isManualOffsetX = offsetX === 0 || offsetX;\n  var isManualOffsetY = offsetY === 0 || offsetY;\n  return {\n    x: isManualOffsetX ? offsetX : calculateXOffset(),\n    y: isManualOffsetY ? offsetY : calculateYOffset()\n  };\n}\n\nexports.getDragPreviewOffset = getDragPreviewOffset;","map":{"version":3,"sources":["../src/OffsetUtils.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA,sBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,wBAAA,CAAA,CAAA;;AAIA,IAAM,YAAY,GAAG,CAArB;;AAEA,SAAA,mBAAA,CAAoC,IAApC,EAA6C;AAC5C,MAAM,EAAE,GAAG,IAAI,CAAC,QAAL,KAAkB,YAAlB,GAAiC,IAAjC,GAAwC,IAAI,CAAC,aAAxD;;AAEA,MAAI,CAAC,EAAL,EAAS;AACR,WAAO,IAAP;AACA;;AAEK,MAAA,EAAA,GAAA,EAAA,CAAA,qBAAA,EAAA;AAAA,MAAE,GAAA,GAAA,EAAA,CAAA,GAAF;AAAA,MAAO,IAAA,GAAA,EAAA,CAAA,IAAP;;AACN,SAAO;AAAE,IAAA,CAAC,EAAE,IAAL;AAAW,IAAA,CAAC,EAAE;AAAd,GAAP;AACA;;AATD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAWA,SAAA,oBAAA,CAAqC,CAArC,EAA2C;AAC1C,SAAO;AACN,IAAA,CAAC,EAAE,CAAC,CAAC,OADC;AAEN,IAAA,CAAC,EAAE,CAAC,CAAC;AAFC,GAAP;AAIA;;AALD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAOA,SAAA,WAAA,CAAqB,IAArB,EAA8B;AAC7B,SACC,IAAI,CAAC,QAAL,KAAkB,KAAlB,KACC,iBAAA,CAAA,SAAA,MAAe,CAAC,QAAQ,CAAC,eAAT,CAAyB,QAAzB,CAAkC,IAAlC,CADjB,CADD;AAIA;;AAED,SAAA,kBAAA,CACC,OADD,EAEC,WAFD,EAGC,WAHD,EAIC,YAJD,EAIqB;AAEpB,MAAI,gBAAgB,GAAG,OAAO,GAAG,WAAW,CAAC,KAAf,GAAuB,WAArD;AACA,MAAI,iBAAiB,GAAG,OAAO,GAAG,WAAW,CAAC,MAAf,GAAwB,YAAvD,CAHoB,CAKpB;;AACA,MAAI,iBAAA,CAAA,QAAA,MAAc,OAAlB,EAA2B;AAC1B,IAAA,iBAAiB,IAAI,MAAM,CAAC,gBAA5B;AACA,IAAA,gBAAgB,IAAI,MAAM,CAAC,gBAA3B;AACA;;AACD,SAAO;AAAE,IAAA,gBAAgB,EAAA,gBAAlB;AAAoB,IAAA,iBAAiB,EAAA;AAArC,GAAP;AACA;;AAED,SAAA,oBAAA,CACC,UADD,EAEC,WAFD,EAGC,YAHD,EAIC,WAJD,EAKC,WALD,EAKiB;AAEhB;AACA;AACA,MAAM,OAAO,GAAG,WAAW,CAAC,WAAD,CAA3B;AACA,MAAM,eAAe,GAAG,OAAO,GAAG,UAAH,GAAgB,WAA/C;AACA,MAAM,+BAA+B,GAAG,mBAAmB,CAC1D,eAD0D,CAA3D;AAGA,MAAM,qBAAqB,GAAG;AAC7B,IAAA,CAAC,EAAE,YAAY,CAAC,CAAb,GAAiB,+BAA+B,CAAC,CADvB;AAE7B,IAAA,CAAC,EAAE,YAAY,CAAC,CAAb,GAAiB,+BAA+B,CAAC;AAFvB,GAA9B;AAIQ,MAAA,WAAA,GAAA,UAAA,CAAA,WAAA;AAAA,MAA0B,YAAA,GAAA,UAAA,CAAA,YAA1B;AACA,MAAA,OAAA,GAAA,WAAA,CAAA,OAAA;AAAA,MAAS,OAAA,GAAA,WAAA,CAAA,OAAT;;AACF,MAAA,EAAA,GAAA,kBAAA,CAAA,OAAA,EAAA,WAAA,EAAA,WAAA,EAAA,YAAA,CAAA;AAAA,MAAE,gBAAA,GAAA,EAAA,CAAA,gBAAF;AAAA,MAAoB,iBAAA,GAAA,EAAA,CAAA,iBAApB;;AAON,MAAM,gBAAgB,GAAG,YAAA;AACxB,QAAM,YAAY,GAAG,IAAI,sBAAA,CAAA,OAAJ,CACpB,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,CADoB,EAEpB,CACC;AACA,IAAA,qBAAqB,CAAC,CAFvB,EAGC;AACA,IAAA,qBAAqB,CAAC,CAAtB,GAA0B,YAA1B,GAAyC,iBAJ1C,EAKC;AACA,IAAA,qBAAqB,CAAC,CAAtB,GAA0B,iBAA1B,GAA8C,YAN/C,CAFoB,CAArB;AAWA,QAAI,CAAC,GAAG,YAAY,CAAC,WAAb,CAAyB,OAAzB,CAAR,CAZwB,CAaxB;;AACA,QAAI,iBAAA,CAAA,QAAA,MAAc,OAAlB,EAA2B;AAC1B;AACA,MAAA,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAP,GAA0B,CAA3B,IAAgC,iBAArC;AACA;;AACD,WAAO,CAAP;AACA,GAnBD;;AAqBA,MAAM,gBAAgB,GAAG,YAAA;AACxB;AACA;AACA,QAAM,YAAY,GAAG,IAAI,sBAAA,CAAA,OAAJ,CACpB,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,CADoB,EAEpB,CACC;AACA,IAAA,qBAAqB,CAAC,CAFvB,EAGC;AACA,IAAA,qBAAqB,CAAC,CAAtB,GAA0B,WAA1B,GAAwC,gBAJzC,EAKC;AACA,IAAA,qBAAqB,CAAC,CAAtB,GAA0B,gBAA1B,GAA6C,WAN9C,CAFoB,CAArB;AAWA,WAAO,YAAY,CAAC,WAAb,CAAyB,OAAzB,CAAP;AACA,GAfD,CA3CgB,CA4DhB;;;AACQ,MAAA,OAAA,GAAA,WAAA,CAAA,OAAA;AAAA,MAAS,OAAA,GAAA,WAAA,CAAA,OAAT;AACR,MAAM,eAAe,GAAG,OAAO,KAAK,CAAZ,IAAiB,OAAzC;AACA,MAAM,eAAe,GAAG,OAAO,KAAK,CAAZ,IAAiB,OAAzC;AACA,SAAO;AACN,IAAA,CAAC,EAAE,eAAe,GAAG,OAAH,GAAa,gBAAgB,EADzC;AAEN,IAAA,CAAC,EAAE,eAAe,GAAG,OAAH,GAAa,gBAAgB;AAFzC,GAAP;AAIA;;AAzED,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BrowserDetector_1 = require(\"./BrowserDetector\");\nvar MonotonicInterpolant_1 = __importDefault(require(\"./MonotonicInterpolant\"));\nvar ELEMENT_NODE = 1;\nfunction getNodeClientOffset(node) {\n    var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n    if (!el) {\n        return null;\n    }\n    var _a = el.getBoundingClientRect(), top = _a.top, left = _a.left;\n    return { x: left, y: top };\n}\nexports.getNodeClientOffset = getNodeClientOffset;\nfunction getEventClientOffset(e) {\n    return {\n        x: e.clientX,\n        y: e.clientY,\n    };\n}\nexports.getEventClientOffset = getEventClientOffset;\nfunction isImageNode(node) {\n    return (node.nodeName === 'IMG' &&\n        (BrowserDetector_1.isFirefox() || !document.documentElement.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n    var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n    var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n    // Work around @2x coordinate discrepancies in browsers\n    if (BrowserDetector_1.isSafari() && isImage) {\n        dragPreviewHeight /= window.devicePixelRatio;\n        dragPreviewWidth /= window.devicePixelRatio;\n    }\n    return { dragPreviewWidth: dragPreviewWidth, dragPreviewHeight: dragPreviewHeight };\n}\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n    // The browsers will use the image intrinsic size under different conditions.\n    // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n    var isImage = isImageNode(dragPreview);\n    var dragPreviewNode = isImage ? sourceNode : dragPreview;\n    var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n    var offsetFromDragPreview = {\n        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y,\n    };\n    var sourceWidth = sourceNode.offsetWidth, sourceHeight = sourceNode.offsetHeight;\n    var anchorX = anchorPoint.anchorX, anchorY = anchorPoint.anchorY;\n    var _a = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight), dragPreviewWidth = _a.dragPreviewWidth, dragPreviewHeight = _a.dragPreviewHeight;\n    var calculateYOffset = function () {\n        var interpolantY = new MonotonicInterpolant_1.default([0, 0.5, 1], [\n            // Dock to the top\n            offsetFromDragPreview.y,\n            // Align at the center\n            offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,\n            // Dock to the bottom\n            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight,\n        ]);\n        var y = interpolantY.interpolate(anchorY);\n        // Work around Safari 8 positioning bug\n        if (BrowserDetector_1.isSafari() && isImage) {\n            // We'll have to wait for @3x to see if this is entirely correct\n            y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n        }\n        return y;\n    };\n    var calculateXOffset = function () {\n        // Interpolate coordinates depending on anchor point\n        // If you know a simpler way to do this, let me know\n        var interpolantX = new MonotonicInterpolant_1.default([0, 0.5, 1], [\n            // Dock to the left\n            offsetFromDragPreview.x,\n            // Align at the center\n            offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,\n            // Dock to the right\n            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth,\n        ]);\n        return interpolantX.interpolate(anchorX);\n    };\n    // Force offsets if specified in the options.\n    var offsetX = offsetPoint.offsetX, offsetY = offsetPoint.offsetY;\n    var isManualOffsetX = offsetX === 0 || offsetX;\n    var isManualOffsetY = offsetY === 0 || offsetY;\n    return {\n        x: isManualOffsetX ? offsetX : calculateXOffset(),\n        y: isManualOffsetY ? offsetY : calculateYOffset(),\n    };\n}\nexports.getDragPreviewOffset = getDragPreviewOffset;\n//# sourceMappingURL=OffsetUtils.js.map"]},"metadata":{},"sourceType":"script"}